```
(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))

```
- 下面分析一下p1和p2的内部过程：
```
p1:
  a. 获取x1的值
  b. 获取x2的值
  c. 计算新值new-value = x1 * x2
  d. (set! x new-value)

p2:
  u. 获取x1的值
  v. 获取x2的值
  w. 获取x3的值
  x. 计算新值new-value = x1 * x2 * x3
  y. (set! x new-value)
```
- 通过简单的排列组合可得到下面几种情况：
    - 1.`p1 --> p2`或`p2 --> p1`，得到结果1 000 000
    - 2.`a --> p2 --> b --> c --> d`，得到结果10 000
    - 3.`a --> b --> p2 --> c --> d`，得到结果100
    - 4.`u --> p1 --> v --> w --> x --> y`，得到结果100 000
    - 5.`u --> v --> p1 --> w --> x --> y`，得到结果10 000
    - 6.`u --> v --> w --> p1 --> x --> y`，得到结果1 000
    
    共有`5`种可能的值。
- 如果改用串行化的话就只有`1 000 000`一种值。